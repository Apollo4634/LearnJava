# 类加载机制

类从被加载到虚拟机内存中，到卸载出内存为止，整个生命周期包括：

![img](http://static.zybuluo.com/Rico123/ojhhtids41ivtuowfj74mkb2/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B)

其中，验证（Verification）、准备（Preparation）和解析（Resolution）统称为连接（Linking）。

通常情况下类的加载必须按照上述步骤完成，但是解析阶段则不一定：某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称动态绑定）。

## 类加载的时机

虚拟机规范并没有明确何时开始执行类加载的第一个阶段（加载和类加载有所不同，加载是类加载的第一步），但是规定了**有且只有**以下5种情况出现时必须立即对类进行初始化（Initialization），而加载、验证、准备自然需要在此之前完成：

* 遇到`new`、`getstatic`、`putstatic`或`invokestatic`这四条字节码指令（注意，`newarray`指令触发的只是数组类型本身的初始化，而不会导致其相关类型的初始化，比如，`new String[]`只会直接触发`String[]`类的初始化，也就是触发对类`[Ljava.lang.String`的初始化，而直接不会触发String类的初始化）时，如果类没有进行过初始化，则需要先对其进行初始化。生成这四条指令的最常见的Java代码场景是：

  **1）**使用new关键字实例化对象的时候；

  **2）**读取或设置一个类的静态字段（被final修饰，已在编译器把结果放入常量池的静态字段除外）的时候；

  **3）**调用一个类的静态方法的时候。

* 使用`java.lang.reflect`包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。

* 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。

* 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。

* 当使用`JDK 1.7`动态语言支持时，如果一个`java.lang.invoke.MethodHandle`实例最后的解析结果`REF_getstatic`、`REF_putstatic`、`REF_invokeStatic`的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化

<br>

# 类加载的过程

### 加载

此阶段需要完成以下3件事情：

* 通过一个类的全限定名来获取该class文件的二进制字节流。
* 将字节流的静态存储结构转化为方法区的运行时数据结构。
* 为上面的class文件，在堆中生成一个`java.lang.Class`对象对该类的数据访问入口

### 验证

这个阶段主要是验证被加载的类是否正确。目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
流程：文件格式验证、元数据验证、字节码验证、符号引用验证

### 准备

该阶段就是正式为类变量分配内存并设置类变量的初始值，注意类变量使用的内存在方法区上分配。（类变量是static修饰的变量，不包括实例变量，实例变量将会在对象实例化的时候随着对象一起分配在Java堆上）

### 解析

该阶段就是将jvm中常量池内的符合引用替换为直接引用的过程。符号引用、直接引用

### 初始化









<br>

---

**参考资料**

1. 《深入理解Java虚拟机：JVM高级特性与最佳实践》 周志明，机械工业出版社，第7章
2.  [JVM类生命周期概述：加载时机与加载过程 - Rico's Blogs - CSDN博客](https://blog.csdn.net/justloveyou_/article/details/72466105)