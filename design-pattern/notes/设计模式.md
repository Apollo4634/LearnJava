# 设计模式

**设计模式的六大原则**  

开闭原则、依赖倒转原则、里氏代换原则（Liskov Substitution Principle）、接口隔离原则（Interface Segregation Principle）、迪米特法则（最少知道原则）（Demeter Principle）、合成复用原则（Composite Reuse Principle）  

**了解23种设计模式**

1. 创建型模式：单例、简单工厂、工厂方法、抽象工厂、建造者模式、原型模式。

2. 结构型模式：适配器、桥接、装饰、组合、外观、享元、代理。

3. 行为型模式：模版方法、命令、迭代器、观察者、中介者、备忘录、解释器、状态、策略、责任链、访问者。

**会使用常用设计模式**

1. 单例的七种写法：懒汉式（线程不安全）、懒汉式（线程安全）、饿汉、饿汉（变种、静态内部类、枚举、双重校验锁）
2. 工厂、单例、适配器、装饰、外观、代理、策略、模板方法、观察者等模式必须掌握 
3. 不用synchronized和lock，实现线程安全的单例模式
4. 实现AOP
5. 实现IOC
6. nio和reactor设计模式

## 一、设计原则
**1. 开放-关闭原则（Open Close Principle）**  

> 定义：  
>   类应该对扩展开放，对修改关闭。也叫开闭原则、开放封闭原则。  

说明：  
  目标是允许类容易扩展，在不修改现有代码的情况下，就可以搭配新的行为。

**2. 依赖倒转原则（Dependence Inversion Principle）**

> 定义：  
>   要依赖抽象，不要依赖具体类。

指导方针：  
- 变量不可以持有具体类的应用，例如使用工厂方法  

- 不要让派生类生成自具体类（尽量派生自接口或抽象类）  

- 不要覆盖基类中已经实现的方法（基类中已实现的方法应由所有子类共享）  

**3.最少知识原则**

> 定义：  
>   要依赖抽象，不要依赖具体类。


##  二、创建型模式

**1. 单例（Singleton）**  

定义：  
  保证一个类仅有一个实例，并提供一个全局访问点。  

**2. 简单工厂（Simple Factory）**

在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。

**3. 工厂方法（Factory Method）**  

定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。

**4. 抽象工厂（Abstract Factory）**  

提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类 。

**5. 生成器（Builder）**  

**6. 原型模式（Prototype）**  



## 二、行为型
**1. 责任链（Chain Of Responsibility）**  

**2. 命令（Command）**  

**3. 解释器（Interpreter）**  

**4. 迭代器（Iterator）**  

**5. 中介者（Mediator）**  

**6. 备忘录（Memento）**  

**7. 观察者（Observer）**  

**8. 状态（State）**  

**9. 策略（Strategy）**  

**10. 模板方法（Template Method）**  

**11. 访问者（Visitor）**  

**12. 空对象（Null）**  


## 三、结构型
**1. 适配器（Adapter）**  

> 定义：  
>  将一个类的接口转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以相互合作。  

a) 使用适配器的过程：  

- 用户通过目标接口调用适配器的方法对适配器发出请求  

- 适配器使用被适配者接口，把请求转换成被适配者的一个或多个调用接口

- 用户接受到调用的结果，但并不知道这一切是适配器在起转换作用

b) 类适配器和对象适配器

在Java中由于没有多重继承，只能使用对象适配器，其通过适配器与被适配者的组合实现目标接口的功能。例如，我们已经编写了A类，此时想在A类的基础上适配，从而实现B类的功能，那么可以使用适配器。该场景下，A类是被适配者，B类是目标类。表面上，我们虽然对B类发出了请求，然而内部是通过适配器和A类组合完成了B类的功能。

类适配器则使用继承的适配方法。适配器同时继承了被适配者A和目标类B。适配器使得我们可以通过A类去完成B类的功能，但也可以通过适配器直接使用旧有的A类。

**2. 装饰（Decorator）**  

>  定义：  
>   动态的将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。   

**3. 外观（Facade）**  

> 定义：
>  提供了一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层接口，让子系统更容易使用。  




**2. 桥接（Bridge）**  

**3. 组合（Composite）**  


**6. 享元（Flyweight）**  

**7. 代理（Proxy）**  







---
**参考资料**  
1. 《Head First设计模式》Eric Freeman，ElElisabeth Freeman，中国电力出版社
2. 《设计模式——可复用面向对象软件的基础》 Erich Gamma，Richard Helm，Ralph Johnson，John Vlissides 
3. [To Be Top Javaer - Java工程师成神之路](https://github.com/hollischuang/toBeTopJavaer)
4. [github.com/CyC2018/CS-Notes/notes/设计模式]([https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md](https://github.com/CyC2018/CS-Notes/blob/master/notes/设计模式.md))
5. [GOF23种设计模式精解 ](https://www.cnblogs.com/lqmblog/p/8549833.html)
6. [GOF 23种设计模式](https://blog.csdn.net/zhangcanyan/article/details/51622380)
