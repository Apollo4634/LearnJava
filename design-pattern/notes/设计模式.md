# 设计模式

**设计模式的六大原则**  

开闭原则
依赖倒转原则
里氏代换原则
接口隔离原则
迪米特法则（最少知道原则）
合成复用原则  

**了解23种设计模式**  

1. 创建型模式：单例、简单工厂、工厂方法、抽象工厂、建造者模式、原型模式。

2. 结构型模式：适配器、桥接、装饰、组合、外观、享元、代理。

3. 行为型模式：模版方法、命令、迭代器、观察者、中介者、备忘录、解释器、状态、策略、责任链、访问者。

**会使用常用设计模式**  

1. 单例的七种写法：懒汉式（线程不安全）、懒汉式（线程安全）、饿汉、饿汉（变种、静态内部类、枚举、双重校验锁）
2. 工厂、单例、适配器、装饰、外观、代理、策略、模板方法、观察者等模式必须掌握 
3. 不用synchronized和lock，实现线程安全的单例模式
4. 实现AOP
5. 实现IOC
6. nio和reactor设计模式

## 一、设计原则  
## 1. 开放-关闭原则（Open Close Principle）  

> 定义：  
>   类应该对扩展开放，对修改关闭。也叫开闭原则、开放封闭原则。  

说明：  
  目标是允许类容易扩展，在不修改现有代码的情况下，就可以搭配新的行为。

## 2. 依赖倒转原则（Dependence Inversion Principle）

> 定义：  
>   要依赖抽象，不要依赖具体类。

指导方针：  
- 变量不可以持有具体类的应用，例如使用工厂方法  

- 不要让派生类生成自具体类（尽量派生自接口或抽象类）  

- 不要覆盖基类中已经实现的方法（基类中已实现的方法应由所有子类共享）  

## 3.最少知识原则

> 定义：  
>   要依赖抽象，不要依赖具体类。


##  二、创建型模式

### 1. 单例（Singleton）  

> 定义：  
>  保证一个类仅有一个实例，并提供一个访问它的全局访问点。  

对一些类来说，只有一个实例很重要。例如，系统中打印机实例，windows操作系统中的回收站和任务管理器，数字滤波器中的AD转换器。

为了实现只有一个实例和一个全局访问点得 意图，通常会将构造器设为private，并将唯一的那个实例设为类的静态成员。客户只能通过单例类的`getInstance`方法获取这个唯一的实例。

实例可以在静态成员类加载时直接初始化，也可以在`getInstance`方法被调用时初始化。由此产生了饿汉式和懒汉式两种主要的写法。饿汉式天然满足线程安全的要求，但是不管是否使用这个实例都要初始化的原因，这种方法更浪费资源。懒汉式仅在需要时实例化，这种做法带来了线程不安全的问题。这里可以使用synchronized关键字对`getInstance`方法进行同步，也可以在此基础上进一步的使用volatile关键字修饰单例类的那个静态成员。另外还有其他几种写法，在此不一一展开，具体包括：  

`饿汉式、懒汉式（线程安全）、懒汉式（线程不安全）、双重校验锁、静态内部类实现、枚举实现、容器实现`



### 2. 简单工厂（Simple Factory）

在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。

### 3. 工厂方法（Factory Method）  

> 定义：
>   定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。



### 4. 抽象工厂（Abstract Factory）  

提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类 。

### 5. 生成器（Builder）  

### 6. 原型模式（Prototype）  



## 二、行为型

### 1. 责任链（Chain Of Responsibility）  

### 2. 命令（Command）  

### 3. 解释器（Interpreter）  

### 4. 迭代器（Iterator）  

### 5. 中介者（Mediator）  

### 6. 备忘录（Memento）  

### 7. 观察者（Observer）  

> 定义
>   定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。

### 8. 状态（State）  

### 9. 策略（Strategy）  

### 10. 模板方法（Template Method）  

> 定义：
>   在一个方法中定义一个算法的股价，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。

模板方法模式在实现上依靠**继承**。模板方法的抽象类提供了一个具体的方法和若干抽象方法，该具体方法定义了算法的整体框架，抽象方法则定义了整体算法的部分步骤。具体方法调用其他抽象方法从而构建出完整的算法。很显然，子类通过重写这部分抽象方法可以改变算法流程，但整体框架不变。从另一个角度来看，模板方式的抽象类已经实现了算法的主要步骤，因此这部分代码不会重复出现在不同的实现中，开发效率更高。  

Java中的Arrays.sort()就是一个典型的模板方法，该方法调用了compareTo()以完成不同的实现。

**补充说明：**

a）钩子  
钩子是一种声明在抽象类中的方法，但是只有空的或者默认的实现。钩子的存在可以让子类有能力对算法的不同点进行挂钩。要不要挂钩，有子类决定，若子类不挂钩则使用默认的实现，若挂钩则子类需要重写相关方法。（钩子和回调差不多，这里就不展开了）  

钩子和上文描述的抽象方法类似，子类重写方法将影响整体算法。区别在于抽象方法必须重写，不同的子类有不同的实现。而钩子是“可选”的，这些方法有着默认的实现。子类不重写钩子，意味着都是用默认的实现。就如同钩子这个词所隐喻的那样：程序的某些地方存在钩子，你可以把自己的算法挂上去，也可以选择不挂，当你挂上自己的算法时程序也因此改变。  

b）模板方法、策略和工厂方法  
模板方法将部分算法步骤的实现开放，由子类决定如何实现；策略模式封装了可互换的行为，然后使用委托来决定要采用哪一个；工厂方法则由子类决定实例化哪个具体类。  

策略模式的实现依靠**组合**，该模式定义的是算法族，每个算法都是独立，都封装了一套完整的算法，使用者可以选择不同的算法实现。  

工厂方法模式在某种意义上可以理解为特殊的模板方法模式。区别在于工厂方法提供的了一个创建对象方法的接口（也就是工厂方法），这相当于模板方法中的那个实例方法。不同的工厂通过继承的方式重写其中的几个步骤，因此不同的工厂可以生产不同的产品，但是生产出来的对象实现了相同的接口。

### 11. 访问者（Visitor）  

### 12. 空对象（Null）  


## 三、结构型  
### 1. 适配器（Adapter）  

> 定义：  
>  将一个类的接口转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以相互合作。  

a) 使用适配器的过程：  

- 用户通过目标接口调用适配器的方法对适配器发出请求  

- 适配器使用被适配者接口，把请求转换成被适配者的一个或多个调用接口

- 用户接受到调用的结果，但并不知道这一切是适配器在起转换作用

b) 类适配器和对象适配器

在Java中由于没有多重继承，只能使用对象适配器，其通过适配器与被适配者的组合实现目标接口的功能。例如，我们已经编写了A类，此时想在A类的基础上适配，从而实现B类的功能，那么可以使用适配器。该场景下，A类是被适配者，B类是目标类。表面上，我们虽然对B类发出了请求，然而内部是通过适配器和A类组合完成了B类的功能。

类适配器则使用继承的适配方法。适配器同时继承了被适配者A和目标类B。适配器使得我们可以通过A类去完成B类的功能，但也可以通过适配器直接使用旧有的A类。

### 2. 装饰（Decorator）  

>  定义：  
>   动态的将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。   

**补充说明**

a) 继承和装饰

如果想在一个类上添加新的责任，比较常见的做法是使用继承。装饰模式

### 3. 外观（Facade）  

> 定义：
>  提供了一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层接口，让子系统更容易使用。  

几点说明：  

- 外观模式只是按某种使用逻辑去调用若干子系统的相关接口，相当于这些子系统的一种具体封装。表面上外观类的接口实现了某个功能，内部却是外观类调用各个子系统的借口实现的，但是调用外观类接口的人并不知道。

- 外观只是提供更直接的操作，并未将原来的子系统阻隔起来。如果需要子系统类的具体功能，还是可以使用原来的子系统。

- 外观和适配器一样可以包装许多类，但是外观的意图是简化接口，而适配器的意图是将接口转换成不同的接口。

### 4. 桥接（Bridge）       

### 5. 组合（Composite）  


### 6. 享元（Flyweight）  

### 7. 代理（Proxy）  







-----
**参考资料**  
1. 《Head First设计模式》Eric Freeman，ElElisabeth Freeman，中国电力出版社
2. 《设计模式——可复用面向对象软件的基础》 Erich Gamma，Richard Helm，Ralph Johnson，John Vlissides 
3. [To Be Top Javaer - Java工程师成神之路](https://github.com/hollischuang/toBeTopJavaer)
4. [github.com/CyC2018/CS-Notes/notes/设计模式]([https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md](https://github.com/CyC2018/CS-Notes/blob/master/notes/设计模式.md))
5. [GOF23种设计模式精解 ](https://www.cnblogs.com/lqmblog/p/8549833.html)
6. [GOF 23种设计模式](https://blog.csdn.net/zhangcanyan/article/details/51622380)
