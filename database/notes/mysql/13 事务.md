# 事务

## 事务的四大特性

数据库事务必须同时满足以下4个特性：原子性、一致性、隔离性、持久性。

**原子性（Atomic）**

表示组成一个事务的多个数据库操作是一个不可分割的原子单元，只有所有的操作执行成功，整个事务才提交。事务中的任何一个数据库操作失败，已经执行的任何操作都必须撤销，让数据库返回到初始状态。

**一致性（Consistency）**

事务操作成功后，数据所处状态必须和业务逻辑是一致的，即数据不会被破坏。

**隔离性（Isolation）**

在并发数据操作时，不同的事务拥有各自的数据空间，它们的操作不会对对方产生干扰。准确地说，并非要求做到完全不干扰。数据库规定了多种事务隔离级别，不同的隔离级别对应不同的干扰程度，隔离级别越高，数据一致性越好，但并发性越弱。

**持久性（Durability）**

一旦事务提交成功后，事务中所有的数据操作都必须被持久化到数据库中。即使在提交事务后，数据库马上崩溃，在数据库重启时，也必须保证能够通过某种机制恢复数据。

<br>

数据库管理系统一般采用重执行日志来保证原子性、一致性、持久性。重执行日志记录了数据库变化的每一个动作，数据库在一个事务中执行一部分操作后发生错误退出，数据库即可根据重执行日志撤销已经执行的操作，此外，对于已经提交的事务，即使数据库崩溃，在重启数据库时也能够根据日志对尚未持久化的数据进行相应的重执行操作。

<br>

## 事务的并发问题

一个数据库可能有多个客户端并发的访问。如果没有采用合理的隔离措施就可能出现脏读、不可重复读、幻读（虚度）等问题。

**脏读（dirty read）**

A事务读取B事务尚未提交的更改数据，并在这个数据的基础上进行操作。

**不可重复读（unrepeatable read）**

一个事务两次读取同一行的数据，结果得到不同状态的结果。事务A读取了事务B提交的更改后的数据，两次结果相异，不可被信任。

**幻读（phantom read）**

事务A读取了事务B提交的新数据。

**第一类丢失更新**

事务A撤销时，把事务B已经提交的更新数据覆盖了

**第二类丢失更新**

事务A覆盖事务B已经提交的数据，造成事务B所做操作丢失

<br>

## 数据库锁机制

行共享锁、行独占锁、表共享锁、表共享行独占锁、表独占锁

## 事务隔离级别

尽管数据库为用户提供了锁的DML操作方式，但直接使用锁管理是非常麻烦的，因此**数据库为用户提供了自动锁机制。只要用户指定会话的事务隔离级别，数据库就会分析事务中的SQL语句，然后自动为事务操作的数据资源添加上适合的锁**。此外数据库还会维护这些锁，当一个资源上的锁数目太多时，自动进行锁升级以提高系统的运行性能，而这一过程对用户来说完全是透明的。 

ANSI/ISO SQL 92标准定义了4个等级的事务隔离级别，在相同数据环境下，使用相同的输入，执行相同的工作，根据不同的隔离级别，可以导致不同的结果。不同事务隔离级别能够解决的数据并发问题的能力是不同的，如下表：

| 隔离级别         | 脏读   | 不可重复读 | 幻读   | 第一类更新丢失 | 第二类更新丢失       |
| :--------------- | :----- | :--------- | :----- | :------------- | :------------------- |
| Read uncommitted | 可能   | 可能       | 可能   | 不可能         | 可能                 |
| Read committed   | 不可能 | 可能       | 可能   | 不可能         | 可能                 |
| Repeatable read  | 不可能 | 不可能     | 可能   | 不可能         | 不可能（InnoDB可能） |
| Serializable     | 不可能 | 不可能     | 不可能 | 不可能         | 不可能               |

并非所有数据库都支持事务，即使支持也不一定支持所有隔离级别。

## JDBC对事务的支持







<br>

---

**参考资料**

1. 《精通Spring 4.x 企业应用开发实战》陈雄化，电子工业出版社，第11章
2. 





