# 活跃性问题

在编写多线程并发程序时，显而易见的是，我们需要保证线程的安全性，从而确保任何情况下都能正确的执行完任务。安全性和活跃性之间存在某种制衡，使用锁可以确保线程的安全性，但是过度的使用锁可能导致锁顺序死锁。使用线程池可以限制对资源的使用，但是被限制的行为可能导致资源死锁。

通俗地讲，活跃性就是希望程序能够顺利的执行完任务，不会因为无法获得某种资源从而导致任务进入永久等待。（个人总结，仅供参考）失去活跃性的进程表上面一直在执行，然而除非中止并重启，不然没有方法恢复。

<br>

活跃性问题主要涉及三种问题：死锁、饥饿、活锁。

### 死锁

**锁顺序死锁**：两个线程尝试以不同的顺序获得相同的锁。

例如，线程A持有锁L，并尝试获得锁R；同时，线程B持有锁R，并尝试获得锁L。此时，这两个线程将永久的等下去。如果所有线程都以固定的一致的顺序来获得锁，那么就不会出现锁顺序死锁。

**动态的锁顺序死锁**

有些方法看起来是以相同的顺序加锁，但实际上取决于该方法的外部调用。例如：

```
public void func(ClassA a, ClassB b, String[] args) {
	synchronized (a) {
		synchronnized (b) {
			doSomething();
		}
	}
}
```

表面上所有调用都是按先获得锁a再获得锁b的方式执行，然后是否发生死锁还取决于调用顺序，例如：

```
func(a, b, args1)
func(b, a, args2)
```

如果上述两行同时执行，那么就会发生死锁。编写代码时应该注意是否存在嵌套的锁获取操作。避免该类死锁的方法可以用`System.identityHashCode`来定义锁的顺序，具体内容参考《Java并发编程实战》的10.1.2节。总之就是必须用某种方法限制获取锁的顺序。