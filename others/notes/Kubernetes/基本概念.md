# K8s基本概念

Kubernetes中的大部分概念如Node、Pod、Replication Controller、Service等都可以被看作一种资源对象，几乎所有资源对象都可以通过Kubernetes提供的kubectl工具（或者API编程调用）执行增、删、改、查等操作并将其保存在etcd中持久化存储。

相关概念主要包括：

Master, Node, Pod, Label, Republication Controller, Deployment, Horizontal Pod Autoscaler, StatefulSet, Service, Job, Volume,  Persistent Volume, Namespace, Annotation, ConfigMap

<br>

### Master

Kubernetes里的Master指的是集群控制节点，在每个K8s集群里都需要有一个Master来负责整个集群的管理和控制，基本上K8s的所有控制命令都发给它，它负责具体的执行过程。

Master通常会占据一个独立的服务器（高可用部署建议用3台服务器），如果它宕机或者不可用，那么对集群内容器应用的管理都将失效。

在Master上运行着以下关键进程：

- Kubernetes API Server（kube-apiserver）：提供了HTTP Rest接口的关键服务进程，是Kubernetes里所有资源的增、删、改、查等操作的唯一入口，也是集群控制的入口进程）
- Kubernetes Controller Manager（kube-controller-manager）：所有资源对象的自动化控制中心
- Kubernetes Scheduler（kube-scheduler）：负责资源调度的进程。

### Node

除了Master，Kubernetes集群中的其他机器被称为Node.

与Master一样，Node可以是一台物理主机，也可以是一台虚拟机。

Node是K8s集群中的工作负载节点，每个Node都会被Master分配一些工作负载（Docker容器），当某个Node宕机时，其上的工作负载会被Master自动转移到其他节点上。

在每个Node上都运行着以下关键进程：

- kubelet：负责Pod对应的容器的创建、启停等任务，同时与Master密切协作，实现集群管理的基本功能。
- kube-proxy：实现Kubernetes Service的通信与负载均衡机制的重要组件。
- Docker Engine（docker）：Docker引擎，负责本机的容器创建和管理工作

Node可以在运行期间动态增加到Kubernetes集群中，前提是在这个节点上已经正确安装、配置和启动了上述关键进程。在默认情况下kubelet会向Master注册自己。

一旦Node被纳入集群管理范围，kubelet进程就会定时向Master汇报自身的信息。Master根据每个Node的资源使用情况，并实现高效均衡的资源调度策略。超过指定时间不上报信息时，会被Master判定为“失联”，Node的状态被标记为不可用（Not Ready）。

### Pod

Pod是Kubernetes最重要的基本概念，是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。

在组成上，每个Pod都有一个特殊的被称为“根容器”的Pause容器。此外，每个Pod还包含一个或多个紧密相关的用户业务容器。Pause容器与业务无关，其状态可以代表整个容器组的状态，用于判断整体是否死亡。其次，共享Pause容器挂接的Volume，可以简化业务容器之间的通信问题，并解决业务容器之间的文件共享问题。

Kubernetes为每个Pod都分配了唯一的IP地址，称之为Pod IP，一个Pod里的多个容器共享Pod IP地址。

Pod有两种类型：普通的Pod及静态Pod（Static Pod）。后者比较特殊，它并没被存放在Kubernetes的etcd存储里，而是被存放在某个具体的Node上的一个具体文件中，并且只在此Node上启动、运行。普通的Pod一旦被创建，就会被放入etcd中存储，随后会被Master调度到某个具体的Node上并进行绑定（Binding），随后该Pod被
对应的Node上的kubelet进程实例化成一组相关的Docker容器并启动。

默认情况下，当Pod里的某个容器停止时，Kubernetes会自动检测到这个问题并且重新启动这个Pod（重启Pod里的所有容器），如果Pod所在的Node宕机，就会将这个Node上的所有Pod重新调度到其他节点上

> Pod、容器与Node的关系，简单来说就是有好多物理主机，其中一台（或者更多台）作为Master并负责调度，其他的是Node，Node里有若干Pod，每个Pod里装了一组业务相关的容器（例如docker容器）。

Docker Volume在Kubernetes里也有对应的概念—Pod Volume，后者有一些扩展，比如可以用分布式文件系统GlusterFS实现后端存储功能；Pod Volume是被定义在Pod上，然后被各个容器挂载到自己的文件系统中。

Event是一个事件的记录，记录了事件的最早产生时间、最后重现时间、重复次数、发起者、类型，以及导致此事件的原因等众多信息。Event通常会被关联到某个具体的资源对象上，是排查故障的重要参考信息。

在Kubernetes里，一个计算资源进行配额限定时需要设定以下两个参数：

- Requests：该资源的最小申请量，系统必须满足要求。
- Limits：该资源最大允许使用的量，不能被突破，当容器试图使用超过这个量的资源时，可能会被K8s杀掉并重启。

### Label

Label（标签）是一个key=value的键值对，其中key与value由用户自己指定。

Label可以被附加到各种资源对象上，例如Node、Pod、Service、RC等，一个资源对象可以定义任意数量的Label，同一个Label也可以被添加到任意数量的资源对象上。Label通常在资源对象定义时确定，也可以在对象创建后动态添加或者删除。

常见的Label有：版本标签release（stable、canary等）、环境标签environment、架构标签tier（frontend、backend、middleware等）、分区标签partition、质量管控标签track（daily、weekly）等等。

可以通过Label Selector（标签选择器）查询和筛选拥有某些Label的资源对象，Kubernetes通过这种方式实
现了类似SQL的简单又通用的对象查询机制。Selector可以使用等式（=, !=）、集合两种表达方式（in, notin）。matchLabels用于定义一组Label，与直接写在Selector中的作用相同；matchExpressions用于定义一组基于集合的筛选条件，可用的条件运算符包括In、NotIn、Exists和DoesNotExist。例如：

```
selector:
  matchLabels:
    component: redis
  matchExpressions:
    - {key: tier, operator: In, values: [cache]}
    - {key: environment, operator: NotIn, values: [dev]}
```

### Replication Controller

Replication Controller（简称RC），定义了一个期望的场景，即声明某种Pod的副本数量在任意时刻都符合某个预期值，所以RC的定义包括如下几个部分。

- Pod期待的副本数量。
- 用于筛选目标Pod的Label Selector。
- 当Pod的副本数量小于预期数量时，用于创建新Pod的Pod模板（template）

